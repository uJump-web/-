{"ast":null,"code":"'use strict';\n\nconst Apply = Function.prototype.apply;\nconst privateMap = new WeakMap(); // For making private properties.\n\nfunction internal(obj) {\n  if (!privateMap.has(obj)) {\n    privateMap.set(obj, {});\n  }\n\n  return privateMap.get(obj);\n}\n/** Class EventEmitter for event-driven architecture. */\n\n\nexport default class EventEmitter {\n  /**\n   * Constructor.\n   *\n   * @constructor\n   * @param {number|null} maxListeners.\n   * @param {object} localConsole.\n   *\n   * Set private initial parameters:\n   *   _events, _callbacks, _maxListeners, _console.\n   *\n   * @return {this}\n   */\n  constructor(maxListeners = null, localConsole = console) {\n    const self = internal(this);\n    self._events = new Set();\n    self._callbacks = {};\n    self._console = localConsole;\n    self._maxListeners = maxListeners === null ? null : parseInt(maxListeners, 10);\n    return this;\n  }\n  /**\n   * Add callback to the event.\n   *\n   * @param {string} eventName.\n   * @param {function} callback\n   * @param {object|null} context - In than context will be called callback.\n   * @param {number} weight - Using for sorting callbacks calls.\n   *\n   * @return {this}\n   */\n\n\n  _addCallback(eventName, callback, context, weight) {\n    this._getCallbacks(eventName).push({\n      callback,\n      context,\n      weight\n    }); // Sort the array of callbacks in\n    // the order of their call by \"weight\".\n\n\n    this._getCallbacks(eventName).sort((a, b) => a.weight > b.weight);\n\n    return this;\n  }\n  /**\n   * Get all callback for the event.\n   *\n   * @param {string} eventName\n   *\n   * @return {object|undefined}\n   */\n\n\n  _getCallbacks(eventName) {\n    return internal(this)._callbacks[eventName];\n  }\n  /**\n   * Get callback's index for the event.\n   *\n   * @param {string} eventName\n   * @param {callback} callback\n   *\n   * @return {number|null}\n   */\n\n\n  _getCallbackIndex(eventName, callback) {\n    return this._has(eventName) ? this._getCallbacks(eventName).findIndex(element => element.callback === callback) : null;\n  }\n  /**\n   * Check if we achive maximum of listeners for the event.\n   *\n   * @param {string} eventName\n   *\n   * @return {bool}\n   */\n\n\n  _achieveMaxListener(eventName) {\n    return internal(this)._maxListeners !== null && internal(this)._maxListeners <= this.listenersNumber(eventName);\n  }\n  /**\n   * Check if callback is already exists for the event.\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   * @param {object|null} context - In than context will be called callback.\n   *\n   * @return {bool}\n   */\n\n\n  _callbackIsExists(eventName, callback, context) {\n    const callbackInd = this._getCallbackIndex(eventName, callback);\n\n    const activeCallback = callbackInd !== -1 ? this._getCallbacks(eventName)[callbackInd] : void 0;\n    return callbackInd !== -1 && activeCallback && activeCallback.context === context;\n  }\n  /**\n   * Check is the event was already added.\n   *\n   * @param {string} eventName\n   *\n   * @return {bool}\n   */\n\n\n  _has(eventName) {\n    return internal(this)._events.has(eventName);\n  }\n  /**\n   * Add the listener.\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   * @param {object|null} context - In than context will be called callback.\n   * @param {number} weight - Using for sorting callbacks calls.\n   *\n   * @return {this}\n   */\n\n\n  on(eventName, callback, context = null, weight = 1) {\n    /* eslint no-unused-vars: 0 */\n    const self = internal(this);\n\n    if (typeof callback !== 'function') {\n      throw new TypeError(`${callback} is not a function`);\n    } // If event wasn't added before - just add it\n    // and define callbacks as an empty object.\n\n\n    if (!this._has(eventName)) {\n      self._events.add(eventName);\n\n      self._callbacks[eventName] = [];\n    } else {\n      // Check if we reached maximum number of listeners.\n      if (this._achieveMaxListener(eventName)) {\n        self._console.warn(`Max listeners (${self._maxListeners})` + ` for event \"${eventName}\" is reached!`);\n      } // Check if the same callback has already added.\n\n\n      if (this._callbackIsExists(...arguments)) {\n        self._console.warn(`Event \"${eventName}\"` + ` already has the callback ${callback}.`);\n      }\n    }\n\n    this._addCallback(...arguments);\n\n    return this;\n  }\n  /**\n   * Add the listener which will be executed only once.\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   * @param {object|null} context - In than context will be called callback.\n   * @param {number} weight - Using for sorting callbacks calls.\n   *\n   * @return {this}\n   */\n\n\n  once(eventName, callback, context = null, weight = 1) {\n    const onceCallback = (...args) => {\n      this.off(eventName, onceCallback);\n      return Apply.call(callback, context, args);\n    };\n\n    return this.on(eventName, onceCallback, context, weight);\n  }\n  /**\n   * Remove an event at all or just remove selected callback from the event.\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   *\n   * @return {this}\n   */\n\n\n  off(eventName, callback = null) {\n    const self = internal(this);\n    let callbackInd;\n\n    if (this._has(eventName)) {\n      if (callback === null) {\n        // Remove the event.\n        self._events.delete(eventName); // Remove all listeners.\n\n\n        self._callbacks[eventName] = null;\n      } else {\n        callbackInd = this._getCallbackIndex(eventName, callback);\n\n        if (callbackInd !== -1) {\n          self._callbacks[eventName].splice(callbackInd, 1); // Remove all equal callbacks.\n\n\n          this.off(...arguments);\n        }\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Trigger the event.\n   *\n   * @param {string} eventName\n   * @param {...args} args - All arguments which should be passed into callbacks.\n   *\n   * @return {this}\n   */\n\n\n  emit(eventName, ...args) {\n    if (this._has(eventName)) {\n      // All callbacks will be triggered sorter by \"weight\" parameter.\n      this._getCallbacks(eventName).forEach(element => Apply.call(element.callback, element.context, args));\n    }\n\n    return this;\n  }\n  /**\n   * Clear all events and callback links.\n   *\n   * @return {this}\n   */\n\n\n  clear() {\n    const self = internal(this);\n\n    self._events.clear();\n\n    self._callbacks = {};\n    return this;\n  }\n  /**\n   * Returns number of listeners for the event.\n   *\n   * @param {string} eventName\n   *\n   * @return {number|null} - Number of listeners for event\n   *                         or null if event isn't exists.\n   */\n\n\n  listenersNumber(eventName) {\n    return this._has(eventName) ? this._getCallbacks(eventName).length : null;\n  }\n\n}","map":{"version":3,"sources":["F:/qianfeng/frame/app/my-app/node_modules/EventEmitter/src/index.js"],"names":["Apply","Function","prototype","apply","privateMap","WeakMap","internal","obj","has","set","get","EventEmitter","constructor","maxListeners","localConsole","console","self","_events","Set","_callbacks","_console","_maxListeners","parseInt","_addCallback","eventName","callback","context","weight","_getCallbacks","push","sort","a","b","_getCallbackIndex","_has","findIndex","element","_achieveMaxListener","listenersNumber","_callbackIsExists","callbackInd","activeCallback","on","TypeError","add","warn","arguments","once","onceCallback","args","off","call","delete","splice","emit","forEach","clear","length"],"mappings":"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","sourcesContent":["'use strict';\n\nconst Apply = Function.prototype.apply;\nconst privateMap = new WeakMap();\n\n// For making private properties.\nfunction internal(obj) {\n  if (!privateMap.has(obj)) {\n    privateMap.set(obj, {});\n  }\n\n  return privateMap.get(obj);\n}\n\n/** Class EventEmitter for event-driven architecture. */\nexport default class EventEmitter {\n  /**\n   * Constructor.\n   *\n   * @constructor\n   * @param {number|null} maxListeners.\n   * @param {object} localConsole.\n   *\n   * Set private initial parameters:\n   *   _events, _callbacks, _maxListeners, _console.\n   *\n   * @return {this}\n   */\n  constructor(maxListeners = null, localConsole = console) {\n    const self = internal(this);\n\n    self._events = new Set();\n    self._callbacks = {};\n    self._console = localConsole;\n    self._maxListeners = maxListeners === null ?\n      null : parseInt(maxListeners, 10);\n\n    return this;\n  }\n\n  /**\n   * Add callback to the event.\n   *\n   * @param {string} eventName.\n   * @param {function} callback\n   * @param {object|null} context - In than context will be called callback.\n   * @param {number} weight - Using for sorting callbacks calls.\n   *\n   * @return {this}\n   */\n  _addCallback(eventName, callback, context, weight) {\n    this._getCallbacks(eventName)\n      .push({\n        callback,\n        context,\n        weight\n      });\n\n    // Sort the array of callbacks in\n    // the order of their call by \"weight\".\n    this._getCallbacks(eventName)\n      .sort((a, b) => a.weight > b.weight);\n\n    return this;\n  }\n\n  /**\n   * Get all callback for the event.\n   *\n   * @param {string} eventName\n   *\n   * @return {object|undefined}\n   */\n  _getCallbacks(eventName) {\n    return internal(this)._callbacks[eventName];\n  }\n\n  /**\n   * Get callback's index for the event.\n   *\n   * @param {string} eventName\n   * @param {callback} callback\n   *\n   * @return {number|null}\n   */\n  _getCallbackIndex(eventName, callback) {\n    return this._has(eventName) ?\n      this._getCallbacks(eventName)\n        .findIndex((element) => element.callback === callback) : null;\n  }\n\n  /**\n   * Check if we achive maximum of listeners for the event.\n   *\n   * @param {string} eventName\n   *\n   * @return {bool}\n   */\n  _achieveMaxListener(eventName) {\n    return (internal(this)._maxListeners !== null &&\n      internal(this)._maxListeners <= this.listenersNumber(eventName));\n  }\n\n  /**\n   * Check if callback is already exists for the event.\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   * @param {object|null} context - In than context will be called callback.\n   *\n   * @return {bool}\n   */\n  _callbackIsExists(eventName, callback, context) {\n    const callbackInd = this._getCallbackIndex(eventName, callback);\n    const activeCallback = callbackInd !== -1 ?\n      this._getCallbacks(eventName)[callbackInd] : void 0;\n\n    return (callbackInd !== -1 && activeCallback &&\n      activeCallback.context === context);\n  }\n\n  /**\n   * Check is the event was already added.\n   *\n   * @param {string} eventName\n   *\n   * @return {bool}\n   */\n  _has(eventName) {\n    return internal(this)._events.has(eventName);\n  }\n\n  /**\n   * Add the listener.\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   * @param {object|null} context - In than context will be called callback.\n   * @param {number} weight - Using for sorting callbacks calls.\n   *\n   * @return {this}\n   */\n  on(eventName, callback, context = null, weight = 1) {\n    /* eslint no-unused-vars: 0 */\n    const self = internal(this);\n\n    if (typeof callback !== 'function') {\n      throw new TypeError(`${callback} is not a function`);\n    }\n\n    // If event wasn't added before - just add it\n    // and define callbacks as an empty object.\n    if (!this._has(eventName)) {\n      self._events.add(eventName);\n      self._callbacks[eventName] = [];\n    } else {\n      // Check if we reached maximum number of listeners.\n      if (this._achieveMaxListener(eventName)) {\n        self._console.warn(`Max listeners (${self._maxListeners})` +\n          ` for event \"${eventName}\" is reached!`);\n      }\n\n      // Check if the same callback has already added.\n      if (this._callbackIsExists(...arguments)) {\n        self._console.warn(`Event \"${eventName}\"` +\n          ` already has the callback ${callback}.`);\n      }\n    }\n\n    this._addCallback(...arguments);\n\n    return this;\n  }\n\n  /**\n   * Add the listener which will be executed only once.\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   * @param {object|null} context - In than context will be called callback.\n   * @param {number} weight - Using for sorting callbacks calls.\n   *\n   * @return {this}\n   */\n  once(eventName, callback, context = null, weight = 1) {\n    const onceCallback = (...args) => {\n      this.off(eventName, onceCallback);\n      return Apply.call(callback, context, args);\n    };\n\n    return this.on(eventName, onceCallback, context, weight);\n  }\n\n  /**\n   * Remove an event at all or just remove selected callback from the event.\n   *\n   * @param {string} eventName\n   * @param {function} callback\n   *\n   * @return {this}\n   */\n  off(eventName, callback = null) {\n    const self = internal(this);\n    let callbackInd;\n\n    if (this._has(eventName)) {\n      if (callback === null) {\n        // Remove the event.\n        self._events.delete(eventName);\n        // Remove all listeners.\n        self._callbacks[eventName] = null;\n      } else {\n        callbackInd = this._getCallbackIndex(eventName, callback);\n\n        if (callbackInd !== -1) {\n          self._callbacks[eventName].splice(callbackInd, 1);\n          // Remove all equal callbacks.\n          this.off(...arguments);\n        }\n      }\n    }\n\n    return this;\n  }\n\n  /**\n   * Trigger the event.\n   *\n   * @param {string} eventName\n   * @param {...args} args - All arguments which should be passed into callbacks.\n   *\n   * @return {this}\n   */\n  emit(eventName, ...args) {\n    if (this._has(eventName)) {\n      // All callbacks will be triggered sorter by \"weight\" parameter.\n      this._getCallbacks(eventName)\n        .forEach((element) =>\n          Apply.call(element.callback, element.context, args)\n        );\n    }\n\n    return this;\n  }\n\n  /**\n   * Clear all events and callback links.\n   *\n   * @return {this}\n   */\n  clear() {\n    const self = internal(this);\n\n    self._events.clear();\n    self._callbacks = {};\n\n    return this;\n  }\n\n  /**\n   * Returns number of listeners for the event.\n   *\n   * @param {string} eventName\n   *\n   * @return {number|null} - Number of listeners for event\n   *                         or null if event isn't exists.\n   */\n  listenersNumber(eventName) {\n    return this._has(eventName) ?\n      this._getCallbacks(eventName).length : null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}